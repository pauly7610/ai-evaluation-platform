{
  "overall": 0.79,
  "metrics": ["syntax_valid", "test_pass", "style_score", "security_score", "latency_ms", "cost_usd"],
  "histogram": [0.5, 0.6, 0.7, 0.8, 0.9],
  "items": [
    {
      "id": "1",
      "prompt": "Write a function to check if a string is a palindrome",
      "output": "def is_palindrome(s):\n    s = s.lower().replace(' ', '')\n    return s == s[::-1]",
      "expected": "function should handle case-insensitivity and spaces",
      "score": 0.88,
      "pass": true,
      "metrics": {
        "syntax_valid": 1.0,
        "test_pass": 0.9,
        "style_score": 0.85,
        "security_score": 0.95,
        "latency_ms": 2340,
        "cost_usd": 0.0032
      }
    },
    {
      "id": "2",
      "prompt": "Create a binary search function in JavaScript",
      "output": "function binarySearch(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  return -1;\n}",
      "expected": "efficient O(log n) implementation with proper bounds",
      "score": 0.92,
      "pass": true,
      "metrics": {
        "syntax_valid": 1.0,
        "test_pass": 1.0,
        "style_score": 0.90,
        "security_score": 1.0,
        "latency_ms": 2680,
        "cost_usd": 0.0038
      }
    },
    {
      "id": "3",
      "prompt": "Write a function to merge two sorted arrays",
      "output": "def merge_sorted(arr1, arr2):\n    result = []\n    i, j = 0, 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            result.append(arr1[i])\n            i += 1\n        else:\n            result.append(arr2[j])\n            j += 1\n    result.extend(arr1[i:])\n    result.extend(arr2[j:])\n    return result",
      "expected": "O(n+m) time complexity with proper handling of remaining elements",
      "score": 0.85,
      "pass": true,
      "metrics": {
        "syntax_valid": 1.0,
        "test_pass": 0.95,
        "style_score": 0.80,
        "security_score": 1.0,
        "latency_ms": 2890,
        "cost_usd": 0.0041
      }
    },
    {
      "id": "4",
      "prompt": "Create a debounce function in TypeScript",
      "output": "function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  delay: number\n): (...args: Parameters<T>) => void {\n  let timeoutId: NodeJS.Timeout;\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func(...args), delay);\n  };\n}",
      "expected": "proper TypeScript typing with generic function signature",
      "score": 0.90,
      "pass": true,
      "metrics": {
        "syntax_valid": 1.0,
        "test_pass": 0.95,
        "style_score": 0.92,
        "security_score": 0.98,
        "latency_ms": 2520,
        "cost_usd": 0.0036
      }
    },
    {
      "id": "5",
      "prompt": "Write a function to find the longest common prefix",
      "output": "def longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n    prefix = strs[0]\n    for s in strs[1:]:\n        while not s.startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    return prefix",
      "expected": "handle edge cases including empty array",
      "score": 0.82,
      "pass": true,
      "metrics": {
        "syntax_valid": 1.0,
        "test_pass": 0.85,
        "style_score": 0.78,
        "security_score": 0.95,
        "latency_ms": 2430,
        "cost_usd": 0.0034
      }
    },
    {
      "id": "6",
      "prompt": "Create a function to validate email addresses",
      "output": "function isValidEmail(email) {\n  const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return regex.test(email);\n}",
      "expected": "basic email validation with regex",
      "score": 0.75,
      "pass": true,
      "metrics": {
        "syntax_valid": 1.0,
        "test_pass": 0.70,
        "style_score": 0.75,
        "security_score": 0.85,
        "latency_ms": 1980,
        "cost_usd": 0.0028
      }
    },
    {
      "id": "7",
      "prompt": "Write a function to deep clone an object",
      "output": "function deepClone(obj) {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (obj instanceof Date) return new Date(obj);\n  if (obj instanceof Array) return obj.map(item => deepClone(item));\n  const cloned = {};\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      cloned[key] = deepClone(obj[key]);\n    }\n  }\n  return cloned;\n}",
      "expected": "recursive deep clone handling arrays, dates, and nested objects",
      "score": 0.87,
      "pass": true,
      "metrics": {
        "syntax_valid": 1.0,
        "test_pass": 0.90,
        "style_score": 0.85,
        "security_score": 0.92,
        "latency_ms": 2750,
        "cost_usd": 0.0039
      }
    },
    {
      "id": "8",
      "prompt": "Create a function to calculate factorial recursively",
      "output": "def factorial(n):\n    if n < 0:\n        raise ValueError(\"Factorial not defined for negative numbers\")\n    if n == 0 or n == 1:\n        return 1\n    return n * factorial(n - 1)",
      "expected": "recursive implementation with base case and error handling",
      "score": 0.84,
      "pass": true,
      "metrics": {
        "syntax_valid": 1.0,
        "test_pass": 0.88,
        "style_score": 0.82,
        "security_score": 0.90,
        "latency_ms": 2180,
        "cost_usd": 0.0030
      }
    },
    {
      "id": "9",
      "prompt": "Write a function to remove duplicates from an array",
      "output": "function removeDuplicates(arr) {\n  return [...new Set(arr)];\n}",
      "expected": "efficient solution using Set",
      "score": 0.78,
      "pass": true,
      "metrics": {
        "syntax_valid": 1.0,
        "test_pass": 0.80,
        "style_score": 0.75,
        "security_score": 1.0,
        "latency_ms": 1650,
        "cost_usd": 0.0023
      }
    },
    {
      "id": "10",
      "prompt": "Create a function to flatten a nested array",
      "output": "function flatten(arr) {\n  return arr.reduce((acc, val) => \n    Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), \n    []\n  );\n}",
      "expected": "recursive flattening of arbitrarily nested arrays",
      "score": 0.86,
      "pass": true,
      "metrics": {
        "syntax_valid": 1.0,
        "test_pass": 0.92,
        "style_score": 0.83,
        "security_score": 0.95,
        "latency_ms": 2240,
        "cost_usd": 0.0031
      }
    }
  ],
  "summary": {
    "total_items": 10,
    "passed": 10,
    "failed": 0,
    "avg_latency_ms": 2364,
    "total_cost_usd": 0.0332,
    "avg_syntax_valid": 1.0,
    "avg_test_pass": 0.885,
    "avg_style_score": 0.825,
    "avg_security_score": 0.950
  }
}
